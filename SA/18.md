## 18. ZpÅ¯soby zajiÅ¡tÄ›nÃ­ spolehlivosti systÃ©mu na Ãºrovni hw a sw, spolehlivostnÃ­ modely. Normy souvisejÃ­cÃ­ s tvorbou spolehlivÃ½ch softwarovÃ½ch systÃ©mÅ¯. [KIV/VSS]
- spolehlivost viz. [#17](17.md)

**ZpÅ¯soby zajiÅ¡tÄ›nÃ­ spolehlivosti**
1. Redundance
   - HW navÃ­c (zÃ¡lohy, redundantnÃ­ vÃ½poÄet (+ hlasovÃ¡nÃ­ o vÃ½sledku))
   - SW navÃ­c (vÃ­ce implementacÃ­ â€“ draÅ¾Å¡Ã­ neÅ¾ HW redundance, ale HW redundance moc nepomÅ¯Å¾e u SW chyb â€“
   taky se mohou vyskytnout vÅ¡ude...)
   - data navÃ­c (duplicitnÃ­ zprÃ¡vy, HammingÅ¯v kÃ³d...)
   - Äas navÃ­c
2. SpolehlivostnÃ­ normy, testovÃ¡nÃ­ a analÃ½za systÃ©mu
   - aby se nic neopomenulo v procesu vÃ½voje

**Redundance**
- BezpeÄnost, vÃ½mÄ›nou za vyÅ¡Å¡Ã­ cenu.
- Dva zÃ¡kladnÃ­ pÅ™edpoklady pro pouÅ¾itÃ­ zÃ¡loh
  - dokÃ¡Å¾i detekovat problÃ©m
  - systÃ©m lze pÅ™epnout
- TÅ™i zÃ¡kladnÃ­ typy zÃ¡loh
  - StudenÃ¡ (cold)
    - zÃ¡loha vypnutÃ¡, po vÃ½padku se aktivuje
    - potÅ™ebuje detekci chyb, potÅ™ebuje dobu na aktivaci
    - po nÄ›jakou dobu nic nefunguje a je zde riziko Å¾e nenabÄ›hne
    - nespotÅ™ebovÃ¡vÃ¡ zdroje â‡’ delÅ¡Ã­ doba do celkovÃ©ho selhÃ¡nÃ­, obÄasnÃ© vÃ½padky, neopotÅ™ebovÃ¡vÃ¡ se
  - TeplÃ¡ (warm)
    - zÃ¡loha zapnutÃ¡ ale neaktivnÃ­, po vÃ½padku zaÄne zpracovÃ¡vat vstup
  - HorkÃ¡ (hot)
    - zÃ¡loha bÄ›Å¾Ã­ paralelnÄ› s hlavnÃ­m vÃ½poÄtem
    - mÅ¯Å¾e slouÅ¾it jako detekce chyb, aktivnÃ­ po celou dobu
    - mÅ¯Å¾e kdykoliv pÅ™evzÃ­t Å™Ã­zenÃ­, spotÅ™ebovÃ¡vÃ¡ zdroje,
    - mÅ¯Å¾e se rozbÃ­t dÅ™Ã­v neÅ¾ na ni dojde â‡’ celkovÃ© selhÃ¡nÃ­ pÅ™ijde dÅ™Ã­v, ale bez vÃ½padkÅ¯

**SpolehlivostnÃ­ normy, testovÃ¡nÃ­ a analÃ½za systÃ©mu**
- SpolehlivostnÃ­ normy zamÄ›Å™enÃ© na
  - Metriky
    - Å™Ã¡dky kÃ³du, cyklomatickÃ¡ sloÅ¾itost, Halsteadova sloÅ¾itost, pokrytÃ­ testy, hustota komentÃ¡Å™Å¯, parametry
      na metodu, promÄ›nnÃ© na metodu, provÃ¡zanost, â€¦
  - Metodiky prÃ¡ce
    - rigidnÃ­ RUP Ã— agilnÃ­ SCRUM
    - dÅ¯raz na dokumentaci rozhodnutÃ­, sledovatelnost vÃ½voje, pochopenÃ­ dÅ¯vodÅ¯ problÃ©mÅ¯
  - FormÃ¡lnÃ­ modely
    - lze dokazovat jejich sprÃ¡vnost a nÃ¡slednÄ› generovat program (Petriho sÃ­tÄ›â€¦)
- DÅ¯kladnÃ© testovÃ¡nÃ­
  - ExistujÃ­ rÅ¯znÃ© druhy testÅ¯
  - Code review zkuÅ¡enÃ½mi programÃ¡tory
- FormÃ¡lnÃ­ normy
  - DÃ¡ se zakÃ¡zat tÅ™eba prÃ¡ce s dynamickou pamÄ›tÃ­ â€“ malloc; dÃ¡ se zakÃ¡zat napÅ™Ã­klad programy s GC; dajÃ­ se
    zakÃ¡zat napÅ™Ã­klad systÃ©my s AIâ€¦
  - **MIL-HDBK-217x** 
    - (military handbook poslednÃ­ F â€“notice2)
    - vojenskÃ¡ pÅ™Ã­ruÄka, dÃ¡ se stÃ¡hnout
    - vÃ½raznÄ› orientovanÃ¡ na HW
    - konkrÃ©tnÃ­ tabulky, co kde za jakÃ¡ hradla a komponenty majÃ­ bÃ½t pouÅ¾ity
      - rÅ¯znÃ© prvky HW + dalÅ¡Ã­ informace o tÄ›chto prvcÃ­ch
    - koeficienty a odhady pro pouÅ¾itÃ­ na zemi a ve vzduchu
    - zaloÅ¾ena na nasbÃ­ranÃ½ch datech a mÄ›Å™enÃ­
  - **IEEE 1633 â€“2008** 
    - (Recommended Practice on Software Reliability)
    - AnalÃ½za a sledovÃ¡nÃ­ SW procesu
    - Predikce spolehlivosti SW na zÃ¡kladÄ› dat mÄ›Å™enÃ½ch pÅ™i vÃ½voji SW, testovÃ¡nÃ­ i po nasazenÃ­
- **CENELEC EN-50128, IEC 62279, IEC 61508**
  - Normy pro drÃ¡Å¾nÃ­ Å™Ã­dÃ­cÃ­ systÃ©my (bezpeÄnost a spolehlivost Å™Ã­dÃ­cÃ­ch systÃ©mÅ¯)
  - NapÅ™. programy s cyklomatickou sloÅ¾itostÃ­ 1, Å¾Ã¡dnÃ© metody AI, â€¦
- **MISRA-C**
  - PodmnoÅ¾ina jazyka C a sada pravidel pro vÃ½voj SW pro kritickÃ© aplikace (pÅ¯vodnÄ› automobilÅ¯ â€“ je od
    Motor Industry Software Reliability Association)
  - 100+ pravidel, nÄ›kterÃ© povinnÃ©, jinÃ© doporuÄenÃ©
  - existujÃ­ na ni validÃ¡tory
  - pÅ™Ã­klady:
    - VÃ½razy s && nebo || v if (â€¦) se povinnÄ› zÃ¡vorkujÃ­ pro logickÃ© operace pouÅ¾Ã­t typ BOOL
      definovanÃ½ pomocÃ­ typedef (statickÃ© analyzÃ¡tory chybu odhalÃ­)
    - LokÃ¡lnÃ­ promÄ›nnÃ© se nesmÃ­ jmenovat stejnÄ› jako globÃ¡lnÃ­ promÄ›nnÃ©
    - OperÃ¡tor ÄÃ¡rka se nepouÅ¾Ã­vÃ¡ (pouze ve for (â€¦))
    - NesmÃ­ se pouÅ¾Ã­vat continue, goto, break (kromÄ› switch)
    - KaÅ¾dÃ½ switch mÃ¡ default ÄÃ¡st, kaÅ¾dÃ½ case mÃ¡ break
    - NepouÅ¾Ã­vat rekurzivnÃ­ funkce
    
    
**SpolehlivostnÃ­ modely**
- obvykle zaloÅ¾enÃ© na statistice
- reÃ¡lnÄ› proto nemÃ¡me jistotu, jak dlouho konkrÃ©tnÃ­ systÃ©m vydrÅ¾Ã­, ale pokud bychom jich provozovali vÃ­ce, tak by
  reÃ¡lnÃ¡ spolehlivost mÄ›la konvergovat k pÅ™edpovÄ›dÃ­m modelu
- mohou bÃ½t analytickÃ© i simulaÄnÃ­

**RozdÄ›lenÃ­ jako jednoduchÃ½ model**
- **Poissonovo rozdÄ›lenÃ­**
  - poÄet vÃ½skytÅ¯ jevÅ¯ v urÄitÃ©m intervalu, kdyÅ¾ jevy nastÃ¡vajÃ­ nezÃ¡visle na sobÄ› a majÃ­ stejnou
    pravdÄ›podobnost (diskrÃ©tnÃ­ rozdÄ›lenÃ­)
  - poÄet jevÅ¯ v urÄitÃ©m ÄasovÃ©m intervalu
  - vÅ¡echny jevy majÃ­ stejnou pravdÄ›podobnost
  - parametr Î» = stÅ™ednÃ­ poÄet udÃ¡lostÃ­ za jednotku Äasu
  - vÃ½znam mÃ¡ Poissonovo rozdÄ›lenÃ­ v teorii hromadnÃ© obsluhy, kde popisuje nÃ¡hodnÃ© jevy, jako jsou pÅ™Ã­chody
   zÃ¡kaznÃ­kÅ¯
- **ExponenciÃ¡lnÃ­ rozdÄ›lenÃ­** 
  - dÃ©lka intervalu mezi udÃ¡lostmi (spojitÃ© rozdÄ›lenÃ­ â€“ Äas)
  - jako dÃ©lka intervalu neÅ¾ dojde k selhÃ¡nÃ­
  - markovskÃ© modely majÃ­ exponenciÃ¡lnÃ­ rozdÄ›lenÃ­ pÅ™echodu ze stavu do stavu
  - parametr Î» = stÅ™ednÃ­ poÄet udÃ¡lostÃ­ za jednotku Äasu
  - stÅ™ednÃ­ doba mezi udÃ¡lostmi = 1 / Î»

**SystÃ©my s nezÃ¡vislÃ½mi prvky**
- SystÃ©m sloÅ¾enÃ½ z vÃ­ce prvkÅ¯ se znÃ¡mÃ½mi vlastnostmi (hradla, CPU a RAM / poÄÃ­taÄeâ€¦)
- MÅ¯Å¾eme je chÃ¡pat jako nezÃ¡vislÃ© (i kdyÅ¾ realita mÅ¯Å¾e bÃ½t sloÅ¾itÄ›jÅ¡Ã­)
- **SÃ©riovÃ© zapojenÃ­**
   - Porucha jednoho prvku rozbije celÃ½ systÃ©m
   - Î» je intenzita poruchy; Ts - stÅ™ednÃ­ doba Å¾ivotnosti
- **ParalelnÃ­ zapojenÃ­**
   - Porucha vÅ¡ech prvkÅ¯ rozbije celÃ½ systÃ©m (staÄÃ­ aby jeden
     fungoval)
   - modelovÃ¡nÃ­ horkÃ© zÃ¡lohy (vÅ¡echny prvky fungujÃ­, ale staÄÃ­ pouze jeden)
- **KombinovanÃ© zapojenÃ­**
   - Kombinace sÃ©riovÃ©ho a paralelnÃ­ho

   <img src="img/18/01.png">
   <img src="img/18/02.png">
- napr CPU, RAM, BUS
   - nejjednodussi pripad zavislych prvku je studena zaloha
      - musime pouzit podminenou ppst pri urcovani ppst poruchy zalohy
   - pokud jsou prvky nezavisle, muzeme poruchy chapat jako nezavisle nahodne jevy
   - pouze modelujeme zapojeni jednotlivych prvku
   - seriove zapojeni
      - porucha jednoh prvku rozbije cely system

        <img src="img/17/13.png">

      - mame `n` nezavislych jevu jaka je ppst ze rozbije jeden z nich?
         - nasobime funkce `R(t)`

        <img src="img/17/14.png">

   - paralelni zapojeni
      - system se rozbije az potom co se rozbiji vsechny prvky (staci alespon jeden aby fungoval)

        <img src="img/17/15.png">

        <img src="img/17/16.png">

      - pokud zname napr `R1(1)` => `Q1(t) = 1 - R1(t)`
      - nasobime funkce `Q(t)`

   - kombinovane modely

       <img src="img/17/17.png">

      - `Q23 = Q2 * Q3 = (1 - R2)(1 - R3)`
      - `R23 = 1 - Q23`
      - `R = R1 * R23` (ppst ze se system rozbije)

      - pro exponencialni doby poruch je `Ri(t) = e^(-Î»it)`

          <img src="img/17/18.png">

         - `Ts` je stredni doba do poruchy celeho systemu

   - toto vse funguje pro systemy ktere jsou
      - neobnovovane
      - konstantni `Î»`
      - nezavisle poruchy

**StavovÃ½ graf**
- Obsahuje ğ‘› prvkÅ¯ oznaÄenÃ½ch ğ´ğ‘›, kaÅ¾dÃ½ mÅ¯Å¾e bÃ½t v provozu nebo porouchanÃ½
- PÅ™echod â€“ 1 porucha nebo 1 oprava
- vhodnÃ½ pro model situacÃ­, kterÃ© nelze pÅ™evÃ©st na sÃ©riovÃ© ani paralelnÃ­ propojenÃ­
- VÃ½poÄet R:
  - seÄteme pravdÄ›podobnosti jednotlivÃ½ch stavÅ¯, pÅ™i kterÃ½ch platÃ­, Å¾e systÃ©m funguje.
  - Za R lze opÄ›t dosadit odpovÃ­dajÃ­cÃ­ distribuÄnÃ­ funkci (obvykle exponenciÃ¡lnÃ­ rozdÄ›lenÃ­).
  
<img src="img/18/03.png">

- problem predhozich prikladu je ze se system nachazi bud v paralelnim nebo seriovym zapojeni (+ kompinace)
   - co kdyz mame system ktery se chova nekde mezi
   - priklad
      - mam 3 prvky `A1`, `A2`, `A3` a potrebuju aby fungovali kterykoliv 2
         - kdyby mi staci 1 bylo by to paralelni zapojeni
         - pro zapojeni 2 ze 3 uz papralelni vzorecek nebude fungovat
      - nakreslim stavovy graf (na zacatku vse funguje)

          <img src="img/17/19.png">

         - ppst napriklad prostredniho stavu ve tretim sloupci je `R1(t)*Q2(t)*Q3(t)`
         - => pokud zname funkce `R(t)` a `Q(t)` pro kazdy prvek -> dokazeme popsat ppst jednotlivych stavu modelu
         - celkova funkce je soucet vsech ppst stavu ve kterem system funguje

             <img src="img/17/20.png">

             <img src="img/17/21.png">

**Strom poruch**
- KlasickÃ½ model zaloÅ¾enÃ½ na mnoÅ¾inÄ› udÃ¡lostÃ­ (Äasto
  poruch), kterÃ© se se systÃ©mem mohou stÃ¡t
- znÃ¡m udÃ¡losti a jejich pravdÄ›podobnosti (funkce v
  Äase / konstanty)
- zadÃ¡ny operÃ¡tory (â€hradlaâ€œ â€“ obvykle AND a OR).
- mame poruchy a jejich ppst
   - muzeme sestavit strom-like strukturu ktera byde vystihovat co musi nastat soucasne a jake poruchy na sebe navazuji
   - zaciname od shora (system je rozbity), co mohlo nastat?
      - mohla se napr rozbit RAM nebo CPU atd
      - pak pokracujeme dal stromem napr proc se rozbila RAM
   - pokud mame dilci ppsti muzeme nad tim udelat nejakou analytiku
      - problem je ale jak zjistit konkretni ppst
   - pouziti napriklad v root-cause analysis
      - napr porucha raketoplanu

  <img src="img/17/23.png">

   <img src="img/18/04.png">

**SystÃ©my se zÃ¡vislÃ½mi prvky**
- **PÅ™Ã­klady:**
  - Je vÄ›tÅ¡Ã­ Å¡ance na poruchu kdyÅ¾ odejdou 2 ze 3 diskÅ¯ a poslednÃ­ je tak maximÃ¡lnÄ› vyuÅ¾Ã­vÃ¡n
  - StudenÃ¡ zÃ¡loha se mÅ¯Å¾e porouchat aÅ¾ po zapnutÃ­ â‡’ jejÃ­ porucha zÃ¡vislÃ¡ na poruÅ¡e primÃ¡rnÃ­ho systÃ©mu.
- **Simulace**
  - Jedu na iterace a pÅ™i kaÅ¾dÃ© si hodÃ­m kostkou jestli se prvek rozbije
  - Lze naprogramovat i sloÅ¾itÃ© vztahy mezi prvky
- **MarkovskÃ© modely**
  - ModelovÃ¡nÃ­ systÃ©mÅ¯ s jasnÄ› urÄenÃ½mi
    - stavy (jako u KA â€“ ve stavu vÅ¡echny vlastnosti systÃ©mu, nemusÃ­m vÄ›dÄ›t jak jsem se tam dostal)
    - pÅ™echody (u kterÃ½ch znÃ¡me intenzitu / Äetnost)
  - MarkovskÃ¡ vlastnost: pravdÄ›podobnost pÅ™echodu mÃ¡ exponenciÃ¡lnÃ­ rozdÄ›lenÃ­ (= model pracuje se spojitÃ½m
    Äasem)
    - PravdÄ›podobnost stavu zÃ¡visÃ­ jen na pÅ™edchozÃ­m stavu a ne na cestÄ› do nÄ›j
  - AbsorpÄnÃ­ stavy â€“ stav kde model konÄÃ­ â€“ nevede z nÄ›j Å¾Ã¡dnÃ¡ hrana
- **NeobnovovanÃ© systÃ©my** 
  - model s absorpÄnÃ­mi stavy, bez cyklÅ¯ â‡’ snadnÃ© Å™eÅ¡enÃ­
  - Po poruÅ¡e se uÅ¾ systÃ©m nevrÃ¡tÃ­ do provozuschopnÃ©ho stavu
  - Å˜eÅ¡enÃ­ soustavy lineÃ¡rnÃ­ch diferenciÃ¡lnÃ­ch rovnic (neexistujÃ­ ustÃ¡lenÃ© pravdÄ›podobnosti)
- **ObnovovanÃ© systÃ©my**
  - grafy obsahujÃ­ cykly (rozbite prvky mohu opravovat)
  - diferencialni rovnice odpadnou
    - zbydou nam linearni rovnice (nemame absopcni stav -> silne souvisly graf)
    - <img src="img/17/28.png">

  - Poruchy jednÃ­m smÄ›rem, opravy druhÃ½m
  - StÃ¡le mohou obsahovat absorpÄnÃ­ stavy (nÄ›co opravit nejde)
  - Model pro nekoneÄnÄ› dlouhou dobu Å¾ivota pokud jde vÅ¡e opravit, lze pracovat s ustÃ¡lenÃ½mi
    pravdÄ›podobnostmi â‡’ mÃ­sto diferenciÃ¡lnÃ­ch rovnic dostanu lineÃ¡rnÃ­ â‡’ snadnÃ© Å™eÅ¡enÃ­

  - priklad
    - mam jednu horkou zalohu
    - mohu si dovolit opravovat oba prvky najednou? (`2Î¼`)

    - <img src="img/17/29.png">

        - `Kp = p1 + p2` (soucet ppsti stavu kdy system funguje)
        - `Ts = (p1 + p2) / (Î» * p2)` (MTTF) ppst toho ze to funguje lomeno ppsti ze ty stavy opustime

  - take se daji na vsechny vyuzit simulace
      - napriklad system ma 2 prvky a kazdy ma studenou zalohu a chci vedet jestli se system proucha do casu `t`
          - zname intenzitu poruch (exp rozdeleni)
          - vygenerujeme 4 rand cisla z daneho rozdeleni

            <img src="img/17/30.png">

            <img src="img/17/31.png">

          - vyslednou hodnotu testujem oproti nasi zvolene kriticke hranici `t`
          - pokud nekolikrat opakujeme a pocitame vysledky
              - defakto monte carlo simulace

  - spolehlivy SW
      - metriky (pokrity kodu testatma, pocet radku na metodu, cyklomaticka slozitost, ...)
          - 100% pokryti testy != 100% spolehlivost
          - doszeni metriky normy nerika nic o spolehlivosti (lide se prilis zameruji na dany standard a ne na to proc se to takhle ma delat)
      - metodiky praci (RUP, SCRUM, ...)
      - formalni metody dokazovani spravnosti (temporalni logika)
          - lze jen na urcite druhy programu (napr na MS Word to neumime)
      - code review zkusenymi programatory