## 01 - Principy správného strukturování software (modularita, skrývání informace, separation of concerns, SOLID), způsoby realizace a význam pro kvalitu sw systémů. [KIV/SAR; KIV/OOP]

**Imperativní programování** (takové jak ho známe, píšeme metody, píšeme jak se má co udělat)
- Strukturované programování umožňuje dělit program na menší jednotky, nemá skoky jako Nestrukturované
  programování
- Dává možnost testovat samostatné části SW apod., OOP, Modulární programování
- Nestrukturované programování - návěští, skoky, celé jeden program - assemblery, COBOL

**Modularita**
- Přístup k vývoji SW, kde systém se skládá z částí (modulů)
- Modul by měl mít jeden význam, jednu zodpovědnost a definovaný interface pro přístup
- Na venek je vidět vždy jen ta veřejná část, tedy rozhraní, které poskytuje přístup k implementaci, která je však skrytá
- Měl by být samostatný s co možná nejmenším počtem vazeb na ostatní moduly (umožňuje izolovaný
  vývoj/testování, znovupoužitelnost)
- Modulární programování
  - Vývoj systému po nepropojených modulech. Každý modul obsahuje nezbytné pro jeho
    funkčnost

**Skrývání informace**
- Definujeme veřejné rozhraní (= specifikace) a potom privátní implementaci
- Interface také někdy jako deklarace, implementace jako definice
- Specifikace poskytuje všechny informace pro použití a nic víc!
- Skrývání informace není zapouzdření (zabalení dat a metod do jedné komponenty). To se jen využívá společně s
  rozhraním, přístupovými právy apod.
- klientovi je poskytnuto rozhraní ale neměl by mít přístup k implementaci samotné
- polymorfismus = Vlastnost OOP jazyků, která umožňuje objektům volat metodu se stejným názvem, ale jinou
  implementací (přetěžování, metody rozhraní, dědění)
- Specifikace musí splňovat
  -	Uživateli poskytuje informace, které uživatel potřebuje pro správné použití programu
  -	Programátorovi poskytuje informace o tom, jak bude jeho program používán. Neposkytuje mu však informaci o tom, jak strukturovat vlastní implementaci. Neposkytuje mu ani informaci o struktuře volajícího.
  -	Specifikace musí být dostatečně formální, aby se oproti ní dali vytvořit automatizované testy.
- výhoda - spolehnutí jakým způsobem je služba implementovaná a změna neovlivní klienta př. RestAPI NASA (na webu popis endpointů s parametry)

**Kontrakt**
- Dohoda mezi tvůrcem entity (metoda, třída, komponenta) a jejími klienty
- definuje podmínky, které je třeba dodržet, možné vedlejší efekty a implementační detaily (celý popis rozhraní)
- Úrovně:
  - syntaktická
    - hlavičky metod, parametry, jaké výjimky vyhazuje apod. (To co se dá vyjádřit programovacím jazykem)
  - sémantická
    - vedlejší efekty
      - podmínky (např. souřadnice obrazce jsou souřadnice levého horního rohu)
      - preconditions/postconditions V jakém stavu má být systém před/po zavolání metody (volat metody v
        tomto pořadí/po jejich volání v nějakém def. stavu)
      - Invariant - podmínka, která platí po celou dobu běhu programu
- Další úrovně:
  - synchronizační (že třeba není thread safety)
  - kvalitativní (rychlost)

**Separation of Concerns**
- problém že modul/vrstva/třída může být nucena vykonávat mnoho navzájem
- řeším je rozdělení nesouvisejícího kódu do aspektů/features které se minimálně překrývají
- jedná se o rozdělení kódu/designu do různých částí tak, aby se z hlediska funkcionality tyto části co nejméně překrývaly
- každá část by měla mít na starost pouze jednu funkcionalitu
- v praxi to znamená, že funkce, třída, modul mají pouze jeden úkol
- výhody
  - redukce duplicity kódu
  - lepší udržovatelnost
  - menší složitost komponent a porozumění kódu
- Např. CSS a HTML v rozdílných souborech, TCP/IP (každá vrstva dělá jednu věc)

**SOLID**
- Single responsibility principle (SRP)
  - Každá třída či modul by měl mít právě jednu zodpovědnost a tato zodpovědnost by měla být danou třídou či
    modulem plně pokryta. Za zodpovědnost se zpravidla považuje nějaká rozumně jednoduchá a oddělená
    funkcionalita. Použití tohoto principu snižuje složitost systému a zvyšuje jeho soudržnost a pochopitelnost
- Open-closed principle (OCP)
  - každá softwarová entita (třída, modul, metoda, kód...) by měla být otevřená rozšířením, ale uzavřená změnám.
  - Využití dědičnosti a rozhraní
  - entitu by mělo být možné rozšířit bez zásahu do jejího kódu
    - Separace rozhraní od implementace
    - wrappery
    - dědičnost
  - porušení např když se použije přímo object a ne rozhraní
  - Výhody: zpětná kompatibilita, neměníme to co funguje, menší provázanost.
- Liskov substitution principle (LSP)
  - jeden z důležitých principů v OOP, který říká, že potomek musí být vždy schopen nahradit svého rodiče bez porušení funkčnosti systému
  - potomek musí umět to samé, co předek, volitelně něco navíc ⇒ lze použít potomka tam, kde je vyžadován předek.
  - Příklad porušení: Square extends Rectangle.
- Interface segregation principle
  - každé rozhraní by mělo být co nejmenší možné a třídy by neměly být nuceny používat rozhraní, která
    nepotřebují. Lze chápat také jako nedávat zbraně, které nejsou potřeba.
- Dependency inversion principle
  - radí, abychom byli závislí na abstrakcích a nikoli na konkrétní implementaci. př: el. spotřebiče připojujeme
    přes standartizovanou zásuvku a nejsou napevno v síti, myš-USB-PC

**Význam uvedených technik**
- vedou k lepší spravovatelnosti kódu, lepší čitelnosti, testovatelnosti, vývoji, udržovatelnost, rozšiřovatelnost
- další programátor je schopen pokračovat ve vývoji, čtením kódu rychle zjistil, jak systém funguje

**Návrhové vzory**
- Lze použít k realizaci těchto technik
- Jsou to šablony pro řešení častých architektonických problémů, na které se můžeme dívat jako na best practices.
- Popsání vzorů usnadňuje komunikaci mezi programátory.
- Slouží také jako inspirace pro vytváření konkrétního návrhu.

  - **Creational patterns** (řeší problémy související s vytvářením objektů v systému) [Design patterns](https://sourcemaking.com/design_patterns)
    - Singleton (šetří zdroje, statický - anti pattern?)
    - Lazy Initialization (Odložená inicializace)
    - Abstract Factory (Abstraktní továrna)
    - Builder (fluent API)
    - Object pool (recyklace objektů)
  - **Structural Patterns** (zaměřují se na možnosti uspořádání jednotlivých tříd nebo komponent v systému Snahou je zpřehlednit systém a využít možností strukturalizace kódu)
    - Proxy (Zástupce)
    - Decorator (Dekorátor)
    - Adapter (Adaptér)
    - Facade (Fasáda)
    - Bridge (Most)
  - **Behavioral Patterns** (zajímají se o chování systému a mohou být založeny na třídách nebo objektech)
    - Command (Příkaz)
    - Inversion of Control & Dependency Injection
    - Iterator (Iterátor)
    - Visitor (Návštěvník)
    - Observer (Pozorovatel)
    - Mediator (Prostředník)